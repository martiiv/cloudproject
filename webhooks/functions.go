package webhooks

import (
	"bytes"
	"cloud.google.com/go/firestore"
	"cloudproject/database"
	"cloudproject/endpoints"
	"cloudproject/structs"
	"cloudproject/utils"
	"crypto/hmac"
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"net/url"
	"strconv"
	"time"
)

// Initialize signature
var SignatureKey = "X-SIGNATURE"

//var Mac hash.Hash
var Secret []byte

func CalculateDeparture(id string) {

	information, _ := database.Client.Collection(database.Collection).Doc(id).Get(database.Ctx)

	var message structs.Webhook
	if err := information.DataTo(&message); err != nil {
		log.Println(err.Error())
	}

	location := message.DepartureLocation

	fmt.Println(location)

	startLat, startLong, err := database.LocationPresent(url.QueryEscape(location))
	if err != nil {
		//Todo error handling
	}

	endLat, endLong, err := database.LocationPresent(url.QueryEscape(message.ArrivalDestination))
	if err != nil {
		//Todo error handling
	}

	coordinates := startLat + "%2C" + startLong + "%3A" + endLat + "%2C" + endLong

	resp, err := http.Get("https://api.tomtom.com/routing/1/calculateRoute/" + coordinates + "/json?instructionsType=coded&traffic=false&avoid=unpavedRoads&travelMode=car&key=" + utils.TomtomKey)
	if err != nil {
	}

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
	}

	var roads structs.AutoGenerated3
	if err = json.Unmarshal(body, &roads); err != nil {
		log.Fatal(err.Error())
	}

	estimatedTravelTime := roads.Routes[0].Summary.TravelTimeInSeconds
	estimatedTravelTimeMinutes := (estimatedTravelTime + endpoints.GetMessageWeight(message.Weather)) / 60

	_, err = database.Client.Collection(database.Collection).Doc(id).Set(database.Ctx, map[string]interface{}{
		"EstimatedTravelTime": estimatedTravelTimeMinutes,
	}, firestore.MergeAll)

}

func CallUrl(url string, content string) {

	req, err := http.NewRequest(http.MethodPost, url, bytes.NewBuffer([]byte(content)))
	if err != nil {
		fmt.Errorf("%v", "Error during request creation.")
		return
	}

	// Hash content
	mac := hmac.New(sha256.New, Secret)
	_, errHash := mac.Write([]byte(content))
	if errHash != nil {
		_ = fmt.Errorf("%v", "Error during content hashing.")
		return
	}
	// Convert to string & add to header
	req.Header.Add(SignatureKey, hex.EncodeToString(mac.Sum(nil)))

	client := http.Client{}
	res, err := client.Do(req)
	if err != nil {
		fmt.Println("Error in HTTP request: " + err.Error())
	}
	response, err := ioutil.ReadAll(res.Body)
	if err != nil {
		fmt.Println("Something is wrong with invocation response: " + err.Error())
	}

	fmt.Println("Webhook invoked. Received status code " + strconv.Itoa(res.StatusCode) +
		" and body: " + string(response))
}

func SendNotification(notificationId string) {
	doc, err := database.Client.Collection(database.Collection).Doc(notificationId).Get(database.Ctx) // Loop through all entries in collection "messages"
	if err != nil {
		_ = errors.New("The notification ID is not in our system")
		return
	}
	var firebase structs.Webhook
	var message string
	var url string
	var TimeUntilInvocation float64

	if err := doc.DataTo(&firebase); err != nil {
		return
	}
	url = firebase.Url
	message = firebase.Weather

	timeS, _ := time.Parse(time.RFC822, firebase.ArrivalTime)
	newTime := timeS.Add(time.Duration(-firebase.EstimatedTravelTime) * time.Minute)
	TimeUntilInvocation = time.Until(newTime).Minutes()
	if TimeUntilInvocation < 0 {
		return
	}
	fmt.Println(TimeUntilInvocation)

	jsonMessage := structs.NotificationResponse{
		Text: message,
	}

	jsonStart := `{"text": "`
	jsonMiddle := jsonMessage.Text
	jsonEnd := `"}`
	jsonData := []byte(jsonStart + jsonMiddle + jsonEnd)

	time.Sleep(time.Duration(TimeUntilInvocation) * time.Minute)

	_, err = database.Get(notificationId)
	if err != nil {
		return
	}

	go CallUrl(url, string(jsonData))

}

func InvokeAll() {
	webhook, err := database.GetAll()
	if err != nil {
		log.Fatalf(err.Error())
	}
	for i := 0; i < len(webhook); i++ {
		go SendNotification(webhook[i].Ref.ID)
	}
}
