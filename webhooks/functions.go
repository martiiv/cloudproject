package webhooks

import (
	"bytes"
	"cloud.google.com/go/firestore"
	"cloudproject/database"
	"cloudproject/endpoints"
	"cloudproject/structs"
	"cloudproject/utils"
	"crypto/hmac"
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"net/url"
	"strconv"
	"time"
)

// SignatureKey Initialize signature
var SignatureKey = "X-SIGNATURE"

// Secret byte array
var Secret []byte

// CalculateDeparture Calculates the time of departure based on weather conditions and traffic messages
// (The traffic messages is considered by the API it self, but has an impact on the time it takes from one
// destination to another)
func CalculateDeparture(id string) {
	// Retrieves the webhook and its information from the database
	webhookInformation, _ := database.Client.Collection(database.Collection).Doc(id).Get(database.Ctx)

	// Defines instance of Webhook-struct
	var message structs.Webhook
	// Tries to input the data from the webhook in the database, into to the struct
	if err := webhookInformation.DataTo(&message); err != nil {
		log.Println(err.Error())
		return
	}

	// Retrieves the latitude and longitude for the departure location
	startLat, startLong, err := database.LocationPresent(url.QueryEscape(message.DepartureLocation))
	if err != nil {
		log.Println("There was an error retrieving the departure locations latitude and longitude." +
			"\n" + err.Error())
		return
	}

	endLat, endLong, err := database.LocationPresent(url.QueryEscape(message.ArrivalDestination))
	if err != nil {
		log.Println("There was an error retrieving the arrival destinations latitude and longitude." +
			"\n" + err.Error())
		return
	}

	// Stores the latitudes and longitudes for the start- and end location to be used in the call to the API.
	// Have to use '%2C' for ',' and '%3A' for ':'
	coordinates := startLat + "%2C" + startLong + "%3A" + endLat + "%2C" + endLong

	// Sends a Get-request to the API to call for route data such as travel time (as we need in this instance)
	resp, err := http.Get("https://api.tomtom.com/routing/1/calculateRoute/" + coordinates + "/json?instructionsType=coded&traffic=false&avoid=unpavedRoads&travelMode=car&key=" + utils.TomtomKey)
	if err != nil {
		log.Println("There was an error retrieving travel data from the TomTom API, Status Code: " + strconv.Itoa(http.StatusInternalServerError) +
			"\n" + err.Error())
		err = utils.TomTomErrorHandling(resp.StatusCode)
		return
	}

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		log.Println("There was an error reading the response body, Status Code: " + strconv.Itoa(http.StatusInternalServerError) +
			"\n" + err.Error())
		return
	}

	var roads structs.AutoGenerated3
	if err = json.Unmarshal(body, &roads); err != nil {
		unmarshalErr := utils.JsonUnmarshalErrorHandling(err)
		log.Println(unmarshalErr)
	}

	estimatedTravelTime := roads.Routes[0].Summary.TravelTimeInSeconds

	// Estimates the travel time based on the actual travel time provided by the API, and adds the weighted time which
	// is calculated using weather conditions.
	estimatedTravelTimeMinutes := (estimatedTravelTime + endpoints.GetMessageWeight(message.Weather)) / 60

	// Updates the estimated travel time for the webhook in the database by setting the newly calculated travel time
	// as the travel time.
	_, err = database.Client.Collection(database.Collection).Doc(id).Set(database.Ctx, map[string]interface{}{
		"EstimatedTravelTime": estimatedTravelTimeMinutes,
	}, firestore.MergeAll)
}

// CallUrl Calls the URL provided in the webhook on invocation
func CallUrl(url string, content string) {

	// Creates a POST request with the content
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewBuffer([]byte(content)))
	if err != nil {
		log.Println("Error during request creation - unable to notify on URL: " + url)
		return
	}

	// Hash content using sha256
	mac := hmac.New(sha256.New, Secret)
	_, errHash := mac.Write([]byte(content))
	if errHash != nil {
		log.Println("Error during content hash.")
		_ = fmt.Errorf("%v", "Error during content hashing.")
		return
	}
	// Convert to string & add to header
	req.Header.Add(SignatureKey, hex.EncodeToString(mac.Sum(nil)))

	client := http.Client{}

	// Send the request
	res, err := client.Do(req)
	if err != nil {
		log.Println("Error in HTTP request: " + err.Error())
		return
	}

	// Reading response
	response, err := ioutil.ReadAll(res.Body)
	if err != nil {
		log.Println("Something is wrong with invocation response, Status Code: " + strconv.Itoa(res.StatusCode) +
			"\n" + err.Error())
		return
	}

	log.Println("Webhook invoked. Received Status Code: " + strconv.Itoa(res.StatusCode) +
		" and body: " + string(response))
}

// SendNotification Creates POST body which is supported by Slack and controls when to invoke the webhooks
func SendNotification(notificationId string) {
	// Checks through all entries in collection "messages" for a webhook with id: notificationId
	doc, err := database.Client.Collection(database.Collection).Doc(notificationId).Get(database.Ctx)
	if err != nil {
		log.Println("Unable to find webhook with ID: " + notificationId + " in the " + database.Collection + " collection")
		_ = errors.New("The notification ID is not in our system")
		return
	}
	var firebase structs.Webhook
	var message string
	var arrivalTime string
	var notificationUrl string
	var timeUntilInvocation float64

	// Tries to add the data from firebase to the Webhook-struct
	if err := doc.DataTo(&firebase); err != nil {
		log.Println("Could not add webhook data to struct. \n" + err.Error())
		return
	}

	notificationUrl = firebase.Url
	message = firebase.Weather
	arrivalTime = firebase.ArrivalTime

	isValid := utils.IsValidInput(arrivalTime)
	if isValid == true {
		timeS, _ := time.Parse(time.RFC822, firebase.ArrivalTime)
		newTime := timeS.Add(time.Duration(-firebase.EstimatedTravelTime) * time.Minute)
		timeUntilInvocation = time.Until(newTime).Minutes()
		if timeUntilInvocation < 0 {
			return
		}
	} else {
		log.Println("Error when parsing arrival time to RFC822-format.")
		return
	}

	jsonMessage := structs.NotificationResponse{
		Text: message,
	}

	// Formats output to be accepted by Slack
	jsonStart := `{"text": "`
	jsonMiddle := jsonMessage.Text
	jsonEnd := `"}`
	jsonData := []byte(jsonStart + jsonMiddle + jsonEnd)

	// Sleeps the go-routine for a given time
	time.Sleep(time.Duration(timeUntilInvocation) * time.Minute)

	// Checks if the user has deleted the webhook while the webhook was asleep
	// if so -> the function returns and the user will not get notified.
	_, err = database.Get(notificationId)
	if err != nil {
		log.Println("Unable to find webhook with ID: " + notificationId)
		return
	}

	// Creates a go routine of the invocation
	go CallUrl(notificationUrl, string(jsonData))
}

// InvokeAll Invokes all webhooks
func InvokeAll() {
	webhook, err := database.GetAll()
	if err != nil {
		log.Println("There has been an error retrieving the webhooks from the database.\n" + err.Error())
		log.Fatalf(err.Error())
		return
	}
	// For each webhook, create a go routine for it
	for i := 0; i < len(webhook); i++ {
		go SendNotification(webhook[i].Ref.ID)
	}
}
